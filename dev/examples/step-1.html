

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Example 1: Solving the heat equation &mdash; ideal.II  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b20cc3f5" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../_static/maths_admonition.css?v=597dd67d" />
      <link rel="stylesheet" type="text/css" href="../_static/dark_mode_css/general.css?v=c0a7eb24" />
      <link rel="stylesheet" type="text/css" href="../_static/dark_mode_css/dark.css?v=70edf1c7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../_static/dark_mode_js/default_dark.js?v=fd565c74"></script>
      <script src="../_static/dark_mode_js/theme_switcher.js?v=358d3910"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Example 2: Solving the linear Stokes equation" href="step-2.html" />
    <link rel="prev" title="Example overview" href="overview.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #450d54" >

          
          
          <a href="../index.html">
            
              <img src="../_static/idealii_logo_text.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Get ideal.II</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Mathematical foundations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../maths/function_spaces.html">Space-time function spaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maths/discretization.html">Finite element discretization</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial examples</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Example overview</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Example 1: Solving the heat equation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#weak-formulation-of-the-heat-equation">Weak formulation of the heat equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#space-time-discretization">Space-time discretization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#problem-statement">Problem statement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#what-is-different-compared-to-a-classical-stationary-fem-code">What is different compared to a classical stationary FEM code?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-commented-program">The commented program</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#include-files">include files</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ideal-ii-includes">ideal.II includes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#deal-ii-includes">deal.II includes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#c-includes">C++ includes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#space-time-functions">Space-time functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-step1-class">The Step1 class</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#step1-step1">Step1::Step1</a></li>
<li class="toctree-l4"><a class="reference internal" href="#step1-run">Step1::run</a></li>
<li class="toctree-l4"><a class="reference internal" href="#step1-make-grid">Step1::make_grid</a></li>
<li class="toctree-l4"><a class="reference internal" href="#step1-time-marching">Step1::time_marching</a></li>
<li class="toctree-l4"><a class="reference internal" href="#step1-setup-system-on-slab">Step1::setup_system_on_slab</a></li>
<li class="toctree-l4"><a class="reference internal" href="#step1-assemble-system-on-slab">Step1::assemble_system_on_slab</a></li>
<li class="toctree-l4"><a class="reference internal" href="#step1-solve-system-on-slab">Step1::solve_system_on_slab</a></li>
<li class="toctree-l4"><a class="reference internal" href="#step1-output-results-on-slab">Step1::output_results_on_slab</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#the-main-function">The main function</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#results">Results</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#possibilities-for-extensions">Possibilities for extensions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-plain-program">The plain program</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="step-2.html">Example 2: Solving the linear Stokes equation</a></li>
<li class="toctree-l1"><a class="reference internal" href="step-3.html">Example 3: Solving the heat equation in parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="step-4.html">Example 4: Solving the Navier-Stokes equations in parallel</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Doxygen API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://instatdealii.github.io/idealii/dev/doxygen/index.html">Index</a></li>
<li class="toctree-l1"><a class="reference external" href="https://instatdealii.github.io/idealii/dev/doxygen/namespaces.html">Namespace List</a></li>
<li class="toctree-l1"><a class="reference external" href="https://instatdealii.github.io/idealii/dev/doxygen/classes.html">Class List</a></li>
<li class="toctree-l1"><a class="reference external" href="https://instatdealii.github.io/idealii/dev/doxygen/files.html">File List</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #450d54" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ideal.II</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Example 1: Solving the heat equation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/examples/step-1.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="example-1-solving-the-heat-equation">
<span id="step-1"></span><h1>Example 1: Solving the heat equation<a class="headerlink" href="#example-1-solving-the-heat-equation" title="Link to this heading"></a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id1">Introduction</a></p>
<ul>
<li><p><a class="reference internal" href="#weak-formulation-of-the-heat-equation" id="id2">Weak formulation of the heat equation</a></p></li>
<li><p><a class="reference internal" href="#space-time-discretization" id="id3">Space-time discretization</a></p></li>
<li><p><a class="reference internal" href="#problem-statement" id="id4">Problem statement</a></p></li>
<li><p><a class="reference internal" href="#what-is-different-compared-to-a-classical-stationary-fem-code" id="id5">What is different compared to a classical stationary FEM code?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-commented-program" id="id6">The commented program</a></p>
<ul>
<li><p><a class="reference internal" href="#include-files" id="id7">include files</a></p>
<ul>
<li><p><a class="reference internal" href="#ideal-ii-includes" id="id8">ideal.II includes</a></p></li>
<li><p><a class="reference internal" href="#deal-ii-includes" id="id9">deal.II includes</a></p></li>
<li><p><a class="reference internal" href="#c-includes" id="id10">C++ includes</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#space-time-functions" id="id11">Space-time functions</a></p></li>
<li><p><a class="reference internal" href="#the-step1-class" id="id12">The Step1 class</a></p>
<ul>
<li><p><a class="reference internal" href="#step1-step1" id="id13">Step1::Step1</a></p></li>
<li><p><a class="reference internal" href="#step1-run" id="id14">Step1::run</a></p></li>
<li><p><a class="reference internal" href="#step1-make-grid" id="id15">Step1::make_grid</a></p></li>
<li><p><a class="reference internal" href="#step1-time-marching" id="id16">Step1::time_marching</a></p></li>
<li><p><a class="reference internal" href="#step1-setup-system-on-slab" id="id17">Step1::setup_system_on_slab</a></p></li>
<li><p><a class="reference internal" href="#step1-assemble-system-on-slab" id="id18">Step1::assemble_system_on_slab</a></p></li>
<li><p><a class="reference internal" href="#step1-solve-system-on-slab" id="id19">Step1::solve_system_on_slab</a></p></li>
<li><p><a class="reference internal" href="#step1-output-results-on-slab" id="id20">Step1::output_results_on_slab</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-main-function" id="id21">The main function</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#results" id="id22">Results</a></p>
<ul>
<li><p><a class="reference internal" href="#possibilities-for-extensions" id="id23">Possibilities for extensions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#the-plain-program" id="id24">The plain program</a></p></li>
</ul>
</nav>
<section id="introduction">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading"></a></h2>
<p>In this tutorial we will look at how the basic concepts of <cite>ideal.II</cite>
can be combined to solve a nonstationary PDE.
This might repeat earlier definitions or explanations,
but the goal is to see how everything will be put together
to show a complete picture. The exemplary equation
will again be the heat equation as it is a linear and scalar equation
with well known terms and operators.</p>
<p>As before, we are interested in the solution on
a space-time domain (cylinder), i.e. <span class="math notranslate nohighlight">\(Q = \Omega\times I\)</span>
with spatial domain <span class="math notranslate nohighlight">\(\Omega\subset\mathbb{R}^d\)</span>
and temporal domain <span class="math notranslate nohighlight">\(I = (0,T)\)</span>.
Given an initial solution <span class="math notranslate nohighlight">\(u^0\in L^2(\Omega)\)</span>,
a force term <span class="math notranslate nohighlight">\(f\in L^2(I,)\)</span> and a Dirichlet
boundary function <span class="math notranslate nohighlight">\(g\in L^2(I,)\)</span> the heat equation reads as:</p>
<div class="admonition-heat-equation-in-strong-formulation maths-equation admonition" id="maths-equation-0">
<p class="admonition-title">Heat equation in strong formulation</p>
<p>The strong formulation reads as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\partial_t u - \Delta u &amp;= f\text{ in }Q\\
u &amp;= g \text{ on }\partial\Omega\times I\\
u &amp;= u^0 \text{ on }\Omega\times\{0\}\end{split}\]</div>
</div>
<section id="weak-formulation-of-the-heat-equation">
<h3><a class="toc-backref" href="#id2" role="doc-backlink">Weak formulation of the heat equation</a><a class="headerlink" href="#weak-formulation-of-the-heat-equation" title="Link to this heading"></a></h3>
<p>As a next step we will derive the weak formulation needed
to do a finite element discretization.
Using the fully continuous function space
<span class="math notranslate nohighlight">\(X=X(I,H^1_0(\Omega))=\{v\in L^2(I,H^1_0(\Omega));\partial_t v\in L^2(I,H^1_0(\Omega)^*)\}\)</span>
we can multiply the strong form by test functions <span class="math notranslate nohighlight">\(\varphi\in X\)</span>
and integrate over <span class="math notranslate nohighlight">\(Q\)</span> to obtain:</p>
<div class="admonition-heat-equation-in-weak-formulation maths-equation admonition" id="maths-equation-1">
<p class="admonition-title">Heat equation in weak formulation</p>
<p>Find <span class="math notranslate nohighlight">\(u\in X+g\)</span>
such that:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\int\limits_0^T\int\limits_\Omega \varphi\partial_t u +
\nabla_x\varphi\nabla_x u\;\mathrm{d}x\;\mathrm{d}t
&amp;= \int\limits_0^T\int\limits_\Omega \varphi f  \;\mathrm{d}x\;\mathrm{d}t\; \forall\varphi\in X\\
u(0,x) &amp;= u^0(x) \text{ in }\Omega\end{split}\]</div>
</div>
</section>
<section id="space-time-discretization">
<h3><a class="toc-backref" href="#id3" role="doc-backlink">Space-time discretization</a><a class="headerlink" href="#space-time-discretization" title="Link to this heading"></a></h3>
<p>While this equation can be solved analytically in some cases,
we are interested in approximately solving the equation
on our computer. Since our space-time cylinder is a cartesian
product we can construct function spaces by tensor products of
spatial and temporal function spaces
and space-time basis functions by multiplication (see <a class="reference internal" href="../maths/function_spaces.html#tp-hilbert-spaces"><span class="std std-ref">Tensor product Hilbert spaces</span></a>).
Therefore, we can split the discretization, starting with the temporal part.</p>
<p>Here, we want to use the discontinuous Galerkin method
so we replace <span class="math notranslate nohighlight">\(X(I,H^1_0(\Omega))\)</span> by the temporally
discontinuous space <span class="math notranslate nohighlight">\(\widetilde{X}(\mathcal{T}_k,H^1_0(\Omega))\)</span>
depending on our temporal triangulation
<span class="math notranslate nohighlight">\(\mathcal{T}_k = \{I_1,I_2,\dots,I_M\}\)</span> with <span class="math notranslate nohighlight">\(I_m=(t_{m-1},t_m)\)</span>.
To account for the discontinuity we introduce the jump terms
<span class="math notranslate nohighlight">\(\varphi_m^+[u]_m=\varphi_m^+(u_m^+-u_m^-)\)</span> and
<span class="math notranslate nohighlight">\(\varphi_0^+[u]_0=\varphi_m^+(u_0^+-u^0)\)</span> and
split the temporal integral at the element faces.
With this we can now state the discontinuous weak formulation:</p>
<div class="admonition-heat-equation-in-discontinuous-weak-formulation maths-equation admonition" id="maths-equation-2">
<p class="admonition-title">Heat equation in discontinuous weak formulation</p>
<p>Find <span class="math notranslate nohighlight">\(u\in \widetilde{X}+g\)</span>
such that:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\sum\limits_{m=1}^{M}&amp;\int\limits_{t_{m-1}}^{t_m}\int\limits_\Omega
    \varphi\partial_t u +
    \nabla_x\varphi\nabla_x u +
\;\mathrm{d}x\;\mathrm{d}t
+\sum\limits_{m=0}^{M}\int\limits_\Omega
    \varphi_m^+[u]_m\;\mathrm{d}x\\
= \sum\limits_{m=1}^{M}&amp;\int\limits_{t_{m-1}}^{t_m}\int\limits_\Omega \varphi f  \;\mathrm{d}x\;\mathrm{d}t\; \forall\varphi\in X\end{split}\]</div>
</div>
<p>The actual refinement is done in two steps.
We start by discretizing the temporal part into piecewise discontinuous
Lagrange elements of order <span class="math notranslate nohighlight">\(r\)</span> to obtain a time-discrete solution
<span class="math notranslate nohighlight">\(u_k\)</span>.
Afterwards we discretize <span class="math notranslate nohighlight">\(\Omega\)</span> with a spatial mesh
<span class="math notranslate nohighlight">\(\mathcal{T}_h\)</span> and <span class="math notranslate nohighlight">\(H^1_0(\Omega)\)</span> by continuous
Lagrange elements of order <span class="math notranslate nohighlight">\(s\)</span> on that mesh.
Then we have the fully discrete function space
<span class="math notranslate nohighlight">\(\widetilde{X}_{kh}^{r,s}(\mathcal{T}_k,\mathcal{T}_h)\)</span>
and solution <span class="math notranslate nohighlight">\(u_{kh}\)</span>.</p>
<p>Finally, we also have to project the boundary function <span class="math notranslate nohighlight">\(g(t,x)\)</span>
into a finite element representation <span class="math notranslate nohighlight">\(\check{g}(t,x)\in\widetilde{X}_{kh}^{r,s}\)</span>.</p>
</section>
<section id="problem-statement">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">Problem statement</a><a class="headerlink" href="#problem-statement" title="Link to this heading"></a></h3>
<p>Finally, we want to state the problem
description of the actual configuration
we want to solve.
The spatial domain will be the unit square
<span class="math notranslate nohighlight">\(\Omega=(0,1)^2\)</span> and the final time is <span class="math notranslate nohighlight">\(T=1\)</span>.
This results in a unit cube space-time cylinder
<span class="math notranslate nohighlight">\(\Sigma=(0,1)^3\)</span>.
To be able to validate our implementation,
we will derive the right hand side
form a simple manufactured solution</p>
<div class="math notranslate nohighlight">
\[u_{\text{exact}}(t,x) = -(x^2-x)(y^2-y)t/4.\]</div>
<p>Inserting this into the strong form, we obtain</p>
<div class="math notranslate nohighlight">
\[f(t,x) = (y^2-y)t/2+(x^2-x)t/2-(x^2-x)(y^2-y)/4\]</div>
</section>
<section id="what-is-different-compared-to-a-classical-stationary-fem-code">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">What is different compared to a classical stationary FEM code?</a><a class="headerlink" href="#what-is-different-compared-to-a-classical-stationary-fem-code" title="Link to this heading"></a></h3>
<p>Here, we want to compare the sequence of function calls with
the step-3 Poisson example from deal.II.
In the stationary example the basic sequence in the main <code class="docutils literal notranslate"><span class="pre">run()</span></code> function
is as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">make_grid()</span></code> produces a uniformly refined unit square mesh</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">setup_system()</span></code> distributes the degrees of freedom on the given mesh and sets the appropriate sizes of vectors and matrices</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">assemble_system()</span></code> loops over all elements in the mesh, computes the local contributions to the matrix and right hand side and adds those to the global matrix $A$ and vector $b$.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solve()</span></code> solves the system $Au=b$ with conjugate gradients CG.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output_results()</span></code> writes $u$ into a vtk file that can be read by visualization tools like VisIt or Paraview</p></li>
</ul>
<p>If you are familiar with time-stepping codes,
you know that we would add a loop over the time-steps around some of these functions.
As we use slabs, the time-marching will be done over those functions
and our main function <code class="docutils literal notranslate"><span class="pre">run()</span></code>  just has the two steps</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">make_grid()</span></code> to produce first a spatial unit square mesh and then propagate it through time in a <code class="docutils literal notranslate"><span class="pre">spacetime::fixed::Triangulation</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">do_time_marching()</span></code> which contains the loop over the <code class="docutils literal notranslate"><span class="pre">TimeIteratorCollection</span></code></p></li>
</ul>
<p>Then inside this time marching loop we call:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">setup_system_on_slab()</span></code> distribute space-time dofs on the given slab and set the sizes of the space-time vectors and matrices</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">assemble_system_on_slab()</span></code> As explained above iterate over all spatial elements and add their local contributions in space-time to the full matrix and right hand side</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solve_system_on_slab()</span></code> solve the slab system with a direct solver. CG is not applicable as the matrix is not symmetrical due to the jump terms and temporal derivative.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output_results_on_slab()</span></code> Write the solution at each temporal dof into its own vtk file.</p></li>
<li><p>preparing the initial value for the next slab (i.e. extracting the final time dof values)</p></li>
</ul>
</section>
</section>
<section id="the-commented-program">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">The commented program</a><a class="headerlink" href="#the-commented-program" title="Link to this heading"></a></h2>
<section id="include-files">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">include files</a><a class="headerlink" href="#include-files" title="Link to this heading"></a></h3>
<section id="ideal-ii-includes">
<h4><a class="toc-backref" href="#id8" role="doc-backlink">ideal.II includes</a><a class="headerlink" href="#ideal-ii-includes" title="Link to this heading"></a></h4>
<div class="admonition-note admonition">
<p class="admonition-title">Note:</p>
<p>To avoid mix-ups ideal.II header files
end on .hh instead of .h (deal.II)
apart from that, many includes are
called the same.</p>
</div>
<p>Include for the TimeIteratorCollection</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ideal.II/base/time_iterator.hh&gt;</span>
</pre></div>
</div>
<p>Space-time quadrature formulae</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ideal.II/base/quadrature_lib.hh&gt;</span>
</pre></div>
</div>
<p>Include DoF centered helper functions</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ideal.II/dofs/slab_dof_tools.hh&gt;</span>
</pre></div>
</div>
<p>actual DoFHandler</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ideal.II/dofs/spacetime_dof_handler.hh&gt;</span>
</pre></div>
</div>
<p>discontinuous Galerkin space-time elements</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ideal.II/fe/fe_dg.hh&gt;</span>
</pre></div>
</div>
<p>FEValues for evaluation of tensor product shape functions</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ideal.II/fe/spacetime_fe_values.hh&gt;</span>
</pre></div>
</div>
<p>Which triangulation to use, here: fixes spatial grid</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ideal.II/grid/fixed_tria.hh&gt;</span>
</pre></div>
</div>
<p>Container class for standard deal vectors</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ideal.II/lac/spacetime_vector.hh&gt;</span>
</pre></div>
</div>
<p>Include vector centered helper functions</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ideal.II/numerics/vector_tools.hh&gt;</span>
</pre></div>
</div>
</section>
<section id="deal-ii-includes">
<h4><a class="toc-backref" href="#id9" role="doc-backlink">deal.II includes</a><a class="headerlink" href="#deal-ii-includes" title="Link to this heading"></a></h4>
<p>needed for the spatial FE description</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deal.II/fe/fe_q.h&gt;</span>
</pre></div>
</div>
<p>needed to generate underlying spatial grid</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deal.II/grid/grid_generator.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deal.II/grid/tria.h&gt;</span>
</pre></div>
</div>
<p>All the linear algebra classes are used from deal.II directly</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deal.II/lac/full_matrix.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deal.II/lac/sparse_direct.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deal.II/lac/sparse_matrix.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deal.II/lac/vector.h&gt;</span>
</pre></div>
</div>
<p>ideal.II uses deal.II functions with set and get time</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deal.II/base/function.h&gt;</span>
</pre></div>
</div>
<p>For now, output is done by hand</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deal.II/numerics/data_out.h&gt;</span>
</pre></div>
</div>
</section>
<section id="c-includes">
<h4><a class="toc-backref" href="#id10" role="doc-backlink">C++ includes</a><a class="headerlink" href="#c-includes" title="Link to this heading"></a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fstream&gt;</span>
</pre></div>
</div>
</section>
</section>
<section id="space-time-functions">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Space-time functions</a><a class="headerlink" href="#space-time-functions" title="Link to this heading"></a></h3>
<p>This function describes the exact solution.
It could be used to calculate L2-errors for example.
Here, it is only used to give the full problem description</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ExactSolution</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">Function</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">ExactSolution</span><span class="p">()</span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">Function</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="p">()</span>
<span class="w">  </span><span class="p">{}</span>
<span class="w">  </span><span class="kt">double</span>
<span class="w">  </span><span class="n">value</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">Point</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">double</span>
<span class="nf">ExactSolution::value</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">Point</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w">             </span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span>
<span class="w">                     </span><span class="p">[[</span><span class="n">maybe_unused</span><span class="p">]]</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">component</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_time</span><span class="p">();</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.25</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is the right hand side function of the heat equation.
It is derived by plugging in the exact solution above into the heat equation.
Note the use of get_time(). This is how ideal.II handles time-dependent functions as this
functionality is already build into deal.II</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">RightHandSide</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">Function</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">double</span>
<span class="w">  </span><span class="n">value</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">Point</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">double</span>
<span class="nf">RightHandSide::value</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">Point</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w">             </span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span>
<span class="w">                     </span><span class="p">[[</span><span class="n">maybe_unused</span><span class="p">]]</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">component</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">t</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="n">get_time</span><span class="p">();</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">return_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="n">return_value</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="w">  </span><span class="n">return_value</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="w">  </span><span class="n">return_value</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.25</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">return_value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="the-step1-class">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">The Step1 class</a><a class="headerlink" href="#the-step1-class" title="Link to this heading"></a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Step1</span>
<span class="p">{</span>
</pre></div>
</div>
<p>public functions, as in most tutorial steps of deal.II
these only contain a constructor and <code class="docutils literal notranslate"><span class="pre">run()</span></code> function.
For the constructor we want to be able to easily switch polynomial degrees
in space and time.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">Step1</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">spatial_degree</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">temporal_degree</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span>
<span class="w">  </span><span class="nf">run</span><span class="p">();</span>
</pre></div>
</div>
<p>Private functions doing the actual work.
These do what their name suggests and should mostly be familiar
if you followed some of the deal.II tutorial steps.
The only new function is the <code class="docutils literal notranslate"><span class="pre">time_marching()</span></code> function,
which handles the iteration over the space-time slabs.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span>
<span class="w">  </span><span class="n">make_grid</span><span class="p">();</span>
<span class="w">  </span><span class="kt">void</span>
<span class="w">  </span><span class="nf">time_marching</span><span class="p">();</span>
<span class="w">  </span><span class="kt">void</span>
<span class="w">  </span><span class="nf">setup_system_on_slab</span><span class="p">();</span>
<span class="w">  </span><span class="kt">void</span>
<span class="w">  </span><span class="nf">assemble_system_on_slab</span><span class="p">();</span>
<span class="w">  </span><span class="kt">void</span>
<span class="w">  </span><span class="nf">solve_system_on_slab</span><span class="p">();</span>
<span class="w">  </span><span class="kt">void</span>
<span class="w">  </span><span class="nf">output_results_on_slab</span><span class="p">();</span>
</pre></div>
</div>
<p>Space-time collections of slab objects.</p>
<p>The fixed triangulation shares a pointer to the spatial mesh
such that all slabs operate on the same mesh.
Without adaptivity this is the best choice as it saves on memory</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">idealii</span><span class="o">::</span><span class="n">spacetime</span><span class="o">::</span><span class="n">fixed</span><span class="o">::</span><span class="n">Triangulation</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">triangulation</span><span class="p">;</span>
<span class="w">  </span><span class="n">idealii</span><span class="o">::</span><span class="n">spacetime</span><span class="o">::</span><span class="n">DoFHandler</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w">           </span><span class="n">dof_handler</span><span class="p">;</span>
<span class="w">  </span><span class="n">idealii</span><span class="o">::</span><span class="n">spacetime</span><span class="o">::</span><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w">          </span><span class="n">solution</span><span class="p">;</span>
</pre></div>
</div>
<p>The space-time finite element description</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">idealii</span><span class="o">::</span><span class="n">spacetime</span><span class="o">::</span><span class="n">DG_FiniteElement</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fe</span><span class="p">;</span>
</pre></div>
</div>
<p>The following objects are needed on a single slab</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">dealii</span><span class="o">::</span><span class="n">SparsityPattern</span><span class="w">                            </span><span class="n">slab_sparsity_pattern</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">dealii</span><span class="o">::</span><span class="n">AffineConstraints</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">slab_constraints</span><span class="p">;</span>
<span class="w">  </span><span class="n">dealii</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w">                       </span><span class="n">slab_system_matrix</span><span class="p">;</span>
<span class="w">  </span><span class="n">dealii</span><span class="o">::</span><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w">                             </span><span class="n">slab_system_rhs</span><span class="p">;</span>
<span class="w">  </span><span class="n">dealii</span><span class="o">::</span><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w">                             </span><span class="n">slab_initial_value</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">slab</span><span class="p">;</span><span class="w"> </span><span class="c1">// index of the current slab</span>
</pre></div>
</div>
<p>Struct holding all iterators over the space-time objects.
This is completely optional but hopefully increases readability.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">struct</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">idealii</span><span class="o">::</span><span class="n">slab</span><span class="o">::</span><span class="n">TriaIterator</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w">        </span><span class="n">tria</span><span class="p">;</span>
<span class="w">    </span><span class="n">idealii</span><span class="o">::</span><span class="n">slab</span><span class="o">::</span><span class="n">DoFHandlerIterator</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w">  </span><span class="n">dof</span><span class="p">;</span>
<span class="w">    </span><span class="n">idealii</span><span class="o">::</span><span class="n">slab</span><span class="o">::</span><span class="n">VectorIterator</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">solution</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">slab_its</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<section id="step1-step1">
<h4><a class="toc-backref" href="#id13" role="doc-backlink">Step1::Step1</a><a class="headerlink" href="#step1-step1" title="Link to this heading"></a></h4>
<p>This constructor takes care of initializing all general
objects that are needed, which are:</p>
<ul class="simple">
<li><p>the space-time triangulation</p></li>
<li><p>the DoFHandler, which has to get a pointer to a space-time tria.
because a shared common base class does not work in this case.</p></li>
<li><p>the space-time FiniteElement consisting of:</p>
<ul>
<li><p>a spatial continuous Lagrangian FE_Q element of order <cite>spatial_degree</cite></p></li>
<li><p>a temporal discontinous Lagrangian FE_DGQ element of order
<cite>temporal degree</cite></p></li>
</ul>
</li>
<li><p>the index of the current slab, which is 0</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Step1</span><span class="o">::</span><span class="n">Step1</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">spatial_degree</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">temporal_degree</span><span class="p">)</span>
<span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="n">triangulation</span><span class="p">()</span><span class="w"> </span><span class="c1">// space-time triangulation</span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">dof_handler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">triangulation</span><span class="p">)</span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">fe</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">dealii</span><span class="o">::</span><span class="n">FE_Q</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">spatial_degree</span><span class="p">),</span><span class="w"> </span><span class="n">temporal_degree</span><span class="p">)</span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">slab</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">{}</span>
</pre></div>
</div>
</section>
<section id="step1-run">
<h4><a class="toc-backref" href="#id14" role="doc-backlink">Step1::run</a><a class="headerlink" href="#step1-run" title="Link to this heading"></a></h4>
<p>This functions is much shorter compared to the stationary versions
as the common FE-code loop is inside the time_marching function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">Step1::run</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">make_grid</span><span class="p">();</span>
<span class="w">  </span><span class="n">time_marching</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="step1-make-grid">
<h4><a class="toc-backref" href="#id15" role="doc-backlink">Step1::make_grid</a><a class="headerlink" href="#step1-make-grid" title="Link to this heading"></a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">Step1::make_grid</span><span class="p">()</span>
<span class="p">{</span>
</pre></div>
</div>
<p>construct a shared pointer to a spatial triangulation</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">space_tria</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">dealii</span><span class="o">::</span><span class="n">Triangulation</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&gt;</span><span class="p">();</span>
</pre></div>
</div>
<p>generate a unit square spatial domain</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">dealii</span><span class="o">::</span><span class="n">GridGenerator</span><span class="o">::</span><span class="n">hyper_cube</span><span class="p">(</span><span class="o">*</span><span class="n">space_tria</span><span class="p">);</span>
</pre></div>
</div>
<p>number of initial slabs in the triangulation</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
</pre></div>
</div>
<p>Fill the internal list with M <code class="docutils literal notranslate"><span class="pre">slab::Triangulation</span></code> objects sharing the
same spatial triangulation</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">triangulation</span><span class="p">.</span><span class="n">generate</span><span class="p">(</span><span class="n">space_tria</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">);</span>
</pre></div>
</div>
<p>Refine the grids on each slab in (space,time)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">triangulation</span><span class="p">.</span><span class="n">refine_global</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>Generate a slab::DoFHandler for each slab::Triangulation</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">dof_handler</span><span class="p">.</span><span class="n">generate</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="step1-time-marching">
<h4><a class="toc-backref" href="#id16" role="doc-backlink">Step1::time_marching</a><a class="headerlink" href="#step1-time-marching" title="Link to this heading"></a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">Step1::time_marching</span><span class="p">()</span>
<span class="p">{</span>
</pre></div>
</div>
<p>This collection simplifies time marching and increments all
registered spacetime iterators with a single function call.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">idealii</span><span class="o">::</span><span class="n">TimeIteratorCollection</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">idealii</span><span class="o">::</span><span class="n">TimeIteratorCollection</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<p>Fill the internal list of vectors with M <code class="docutils literal notranslate"><span class="pre">dealii::Vector&lt;double&gt;</span></code>
vectors.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">solution</span><span class="p">.</span><span class="n">reinit</span><span class="p">(</span><span class="n">triangulation</span><span class="p">.</span><span class="n">M</span><span class="p">());</span>
</pre></div>
</div>
<p>Get iterators to the first slabs</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">slab_its</span><span class="p">.</span><span class="n">tria</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">triangulation</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="w">  </span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">dof_handler</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="w">  </span><span class="n">slab_its</span><span class="p">.</span><span class="n">solution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solution</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</pre></div>
</div>
<p>Register iterators with the TimeIteratorCollection</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">tic</span><span class="p">.</span><span class="n">add_iterator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slab_its</span><span class="p">.</span><span class="n">tria</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">triangulation</span><span class="p">);</span>
<span class="w">  </span><span class="n">tic</span><span class="p">.</span><span class="n">add_iterator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dof_handler</span><span class="p">);</span>
<span class="w">  </span><span class="n">tic</span><span class="p">.</span><span class="n">add_iterator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slab_its</span><span class="p">.</span><span class="n">solution</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">solution</span><span class="p">);</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;*******Starting time-stepping*********&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">  </span><span class="n">slab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>Actual time marching using <code class="docutils literal notranslate"><span class="pre">increment()</span></code></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="o">!</span><span class="n">tic</span><span class="p">.</span><span class="n">at_end</span><span class="p">();</span><span class="w"> </span><span class="n">tic</span><span class="p">.</span><span class="n">increment</span><span class="p">())</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Starting time-step (&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">slab_its</span><span class="p">.</span><span class="n">tria</span><span class="o">-&gt;</span><span class="n">startpoint</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;,&quot;</span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">slab_its</span><span class="p">.</span><span class="n">tria</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>this is the “typical” FE-code loop without the <code class="docutils literal notranslate"><span class="pre">make_grid()</span></code> function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">      </span><span class="n">setup_system_on_slab</span><span class="p">();</span>
<span class="w">      </span><span class="n">assemble_system_on_slab</span><span class="p">();</span>
<span class="w">      </span><span class="n">solve_system_on_slab</span><span class="p">();</span>
<span class="w">      </span><span class="n">output_results_on_slab</span><span class="p">();</span>
</pre></div>
</div>
<p>Extract the subvector of the final temporal DoF of this slab.
This is needed as the initial value for the next slab</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">      </span><span class="n">idealii</span><span class="o">::</span><span class="n">slab</span><span class="o">::</span><span class="n">VectorTools</span><span class="o">::</span><span class="n">extract_subvector_at_time_dof</span><span class="p">(</span>
<span class="w">        </span><span class="o">*</span><span class="n">slab_its</span><span class="p">.</span><span class="n">solution</span><span class="p">,</span>
<span class="w">        </span><span class="n">slab_initial_value</span><span class="p">,</span>
<span class="w">        </span><span class="n">slab_its</span><span class="p">.</span><span class="n">tria</span><span class="o">-&gt;</span><span class="n">temporal</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">n_global_active_cells</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>increase slab index</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">      </span><span class="n">slab</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="step1-setup-system-on-slab">
<h4><a class="toc-backref" href="#id17" role="doc-backlink">Step1::setup_system_on_slab</a><a class="headerlink" href="#step1-setup-system-on-slab" title="Link to this heading"></a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">Step1::setup_system_on_slab</span><span class="p">()</span>
<span class="p">{</span>
</pre></div>
</div>
<p>Distribute spatial and temporal dofs</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">distribute_dofs</span><span class="p">(</span><span class="n">fe</span><span class="p">);</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Number of degrees of freedom: </span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">n_dofs_space</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; (space) * &quot;</span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">n_dofs_time</span><span class="p">()</span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; (time) = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">n_dofs_spacetime</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>On the first slab the initial value vector has to be set to the correct
(spatial) size. For the given <code class="docutils literal notranslate"><span class="pre">ExactSolution</span></code> this is 0.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">slab</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">slab_initial_value</span><span class="p">.</span><span class="n">reinit</span><span class="p">(</span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">n_dofs_space</span><span class="p">());</span>
<span class="w">      </span><span class="n">slab_initial_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
<p>Set homogeneous Dirichlet boundary constraints.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">slab_constraints</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">dealii</span><span class="o">::</span><span class="n">AffineConstraints</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">zero</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">Functions</span><span class="o">::</span><span class="n">ZeroFunction</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="n">idealii</span><span class="o">::</span><span class="n">slab</span><span class="o">::</span><span class="n">VectorTools</span><span class="o">::</span><span class="n">interpolate_boundary_values</span><span class="p">(</span><span class="o">*</span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="p">,</span>
<span class="w">                                                          </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                                                          </span><span class="n">zero</span><span class="p">,</span>
<span class="w">                                                          </span><span class="n">slab_constraints</span><span class="p">);</span>
<span class="w">  </span><span class="n">slab_constraints</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">();</span>
</pre></div>
</div>
<p>Construct the space-time sparsity pattern for this slab.
In time the coupling is determined by the jump terms.
For the forward problem that means temporal elements only couple to their
predecessors, i.e. on the left off-diagonal.
In ideal.II this is referred to as an upwind pattern.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">dealii</span><span class="o">::</span><span class="n">DynamicSparsityPattern</span><span class="w"> </span><span class="nf">dsp</span><span class="p">(</span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">n_dofs_spacetime</span><span class="p">());</span>
<span class="w">  </span><span class="n">idealii</span><span class="o">::</span><span class="n">slab</span><span class="o">::</span><span class="n">DoFTools</span><span class="o">::</span><span class="n">make_upwind_sparsity_pattern</span><span class="p">(</span><span class="o">*</span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="p">,</span><span class="w"> </span><span class="n">dsp</span><span class="p">);</span>
<span class="w">  </span><span class="n">slab_sparsity_pattern</span><span class="p">.</span><span class="n">copy_from</span><span class="p">(</span><span class="n">dsp</span><span class="p">);</span>
</pre></div>
</div>
<p>Reinit the linear algebra objects based on the space-time indices.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">slab_system_matrix</span><span class="p">.</span><span class="n">reinit</span><span class="p">(</span><span class="n">slab_sparsity_pattern</span><span class="p">);</span>
<span class="w">  </span><span class="n">slab_its</span><span class="p">.</span><span class="n">solution</span><span class="o">-&gt;</span><span class="n">reinit</span><span class="p">(</span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">n_dofs_spacetime</span><span class="p">());</span>
<span class="w">  </span><span class="n">slab_system_rhs</span><span class="p">.</span><span class="n">reinit</span><span class="p">(</span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">n_dofs_spacetime</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="step1-assemble-system-on-slab">
<h4><a class="toc-backref" href="#id18" role="doc-backlink">Step1::assemble_system_on_slab</a><a class="headerlink" href="#step1-assemble-system-on-slab" title="Link to this heading"></a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">Step1::assemble_system_on_slab</span><span class="p">()</span>
<span class="p">{</span>
</pre></div>
</div>
<p>Similar to the stationary case we start with a quadrature and <code class="docutils literal notranslate"><span class="pre">FEValues</span></code>
objects</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">idealii</span><span class="o">::</span><span class="n">spacetime</span><span class="o">::</span><span class="n">QGauss</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">quad</span><span class="p">(</span><span class="n">fe</span><span class="p">.</span><span class="n">spatial</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">degree</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">fe</span><span class="p">.</span><span class="n">temporal</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">degree</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>

<span class="w">  </span><span class="n">idealii</span><span class="o">::</span><span class="n">spacetime</span><span class="o">::</span><span class="n">FEValues</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fe_values_spacetime</span><span class="p">(</span>
<span class="w">    </span><span class="n">fe</span><span class="p">,</span>
<span class="w">    </span><span class="n">quad</span><span class="p">,</span>
<span class="w">    </span><span class="n">dealii</span><span class="o">::</span><span class="n">update_values</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">update_gradients</span><span class="w"> </span><span class="o">|</span>
<span class="w">      </span><span class="n">dealii</span><span class="o">::</span><span class="n">update_quadrature_points</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">update_JxW_values</span><span class="p">);</span>
</pre></div>
</div>
<p>To account for jump values we use the <code class="docutils literal notranslate"><span class="pre">FEJumpValues</span></code> class which is
similar to <code class="docutils literal notranslate"><span class="pre">FEFaceValues</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">idealii</span><span class="o">::</span><span class="n">spacetime</span><span class="o">::</span><span class="n">FEJumpValues</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fe_jump_values_spacetime</span><span class="p">(</span>
<span class="w">    </span><span class="n">fe</span><span class="p">,</span>
<span class="w">    </span><span class="n">quad</span><span class="p">,</span>
<span class="w">    </span><span class="n">dealii</span><span class="o">::</span><span class="n">update_values</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">update_gradients</span><span class="w"> </span><span class="o">|</span>
<span class="w">      </span><span class="n">dealii</span><span class="o">::</span><span class="n">update_quadrature_points</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">update_JxW_values</span><span class="p">);</span>

<span class="w">  </span><span class="n">RightHandSide</span><span class="w">      </span><span class="n">right_hand_side</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fe</span><span class="p">.</span><span class="n">dofs_per_cell</span><span class="p">;</span>
</pre></div>
</div>
<p>Number of temporal elements and index of the current element for offset
calculations.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slab_its</span><span class="p">.</span><span class="n">tria</span><span class="o">-&gt;</span><span class="n">temporal</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">n_global_active_cells</span><span class="p">();</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
</pre></div>
</div>
<p>The easiest way to account for jump values is to construct local objects
extruded in the temporal direction, such that they hold information over
all temporal elements, but just the information of a single spatial element</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">dealii</span><span class="o">::</span><span class="n">FullMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cell_matrix</span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">);</span>

<span class="w">  </span><span class="n">dealii</span><span class="o">::</span><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cell_rhs</span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">);</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">dealii</span><span class="o">::</span><span class="n">types</span><span class="o">::</span><span class="n">global_dof_index</span><span class="o">&gt;</span><span class="w"> </span><span class="n">local_spacetime_dof_index</span><span class="p">(</span>
<span class="w">    </span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">);</span>
</pre></div>
</div>
<p>number of space-time and space quadrature points</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n_quad_spacetime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">n_quadrature_points</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n_quad_space</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">quad</span><span class="p">.</span><span class="n">spatial</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span>
</pre></div>
</div>
<p>First, iterate over active spatial elements since reinit is more expensive
in 2d compared to the 1d temporal element.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cell_space</span><span class="w"> </span><span class="o">:</span>
<span class="w">       </span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">spatial</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">active_cell_iterators</span><span class="p">())</span>
<span class="w">    </span><span class="p">{</span>
</pre></div>
</div>
<p>Reset local contributions</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">      </span><span class="n">cell_matrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">      </span><span class="n">cell_rhs</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>recalculate local information for the current spatial element</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">      </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">reinit_space</span><span class="p">(</span><span class="n">cell_space</span><span class="p">);</span>
<span class="w">      </span><span class="n">fe_jump_values_spacetime</span><span class="p">.</span><span class="n">reinit_space</span><span class="p">(</span><span class="n">cell_space</span><span class="p">);</span>
</pre></div>
</div>
<p>get local contribution of the slab_initial_value vector</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">initial_values</span><span class="p">(</span>
<span class="w">        </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">spatial</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">n_quadrature_points</span><span class="p">);</span>
<span class="w">      </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">spatial</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">get_function_values</span><span class="p">(</span><span class="n">slab_initial_value</span><span class="p">,</span>
<span class="w">                                                         </span><span class="n">initial_values</span><span class="p">);</span>
</pre></div>
</div>
<p>Second, iterate over active temporal elements</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cell_time</span><span class="w"> </span><span class="o">:</span>
<span class="w">           </span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">temporal</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">active_cell_iterators</span><span class="p">())</span>
<span class="w">        </span><span class="p">{</span>
</pre></div>
</div>
<p>As the temporal elements are part of a 1-d triangulation
the indices are ordered from left to right, i.e. startpoint to
endpoint such that the index corresponds to the element number.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">          </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell_time</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">();</span>
</pre></div>
</div>
<p>Recalculate local information for the current temporal element</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">          </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">reinit_time</span><span class="p">(</span><span class="n">cell_time</span><span class="p">);</span>
<span class="w">          </span><span class="n">fe_jump_values_spacetime</span><span class="p">.</span><span class="n">reinit_time</span><span class="p">(</span><span class="n">cell_time</span><span class="p">);</span>
</pre></div>
</div>
<p>Get local space-time dof indices for the current tensor product
cell.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">          </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">get_local_dof_indices</span><span class="p">(</span><span class="n">local_spacetime_dof_index</span><span class="p">);</span>
</pre></div>
</div>
<p>Iterate over space-time quadrature points for
all contributions except for jump terms</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">          </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n_quad_spacetime</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">q</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
</pre></div>
</div>
<p>set the time of the right hand side to the current
quadrature point and get its location.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">              </span><span class="n">right_hand_side</span><span class="p">.</span><span class="n">set_time</span><span class="p">(</span>
<span class="w">                </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">time_quadrature_point</span><span class="p">(</span><span class="n">q</span><span class="p">));</span>
<span class="w">              </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x_q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">space_quadrature_point</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
</pre></div>
</div>
<p>iterate over all space-time dofs of the current element
and calculate contributions at current quadrature point</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">              </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
</pre></div>
</div>
<div class="admonition-note admonition">
<p class="admonition-title">Note:</p>
<p>Usually, weak forms are derived by multiplying the test
function from the right. However, the linear system
multiplies the unknown from the right instead.
Consequently, for unsymmetric matrices like here we
need to switch the row and column indices.</p>
</div>
<p>All indices are offset by the number of space-time DoFs
of the previous temporal elements.</p>
<p><span class="math notranslate nohighlight">\((\partial_t u,v)\)</span></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">                      </span><span class="n">cell_matrix</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">,</span>
<span class="w">                                  </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">)</span><span class="w"> </span><span class="o">+=</span>
<span class="w">                        </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">shape_value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                        </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">shape_dt</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                        </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">JxW</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\((\nabla u, \nabla v)\)</span></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">                      </span><span class="n">cell_matrix</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">,</span>
<span class="w">                                  </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">)</span><span class="w"> </span><span class="o">+=</span>
<span class="w">                        </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">shape_space_grad</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                        </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">shape_space_grad</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                        </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">JxW</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

<span class="w">                    </span><span class="p">}</span><span class="w"> </span><span class="c1">// dofs j</span>
</pre></div>
</div>
<p>Calculate local contribution of the right hand side
function. Since the current quadrature point time
coordinate was set above the call to <code class="docutils literal notranslate"><span class="pre">value(x)</span></code> is
actually an evaluation of f(t,x).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">                  </span><span class="n">cell_rhs</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">)</span><span class="w"> </span><span class="o">+=</span>
<span class="w">                    </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">shape_value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                    </span><span class="n">right_hand_side</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">x_q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">JxW</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="c1">// dofs i</span>

<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="c1">// quad</span>
</pre></div>
</div>
<p>Jump terms just have a spatial quadrature loop</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">          </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n_quad_space</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">q</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
</pre></div>
</div>
<div class="admonition-note admonition">
<p class="admonition-title">Note:</p>
<p>The DoF loops are over space-time indices as the temporal DoFs
are not necessarily on the temporal element edges.
In those cases <span class="math notranslate nohighlight">\(u_m^+\)</span> is a linear combination of
shape functions evaluated at <span class="math notranslate nohighlight">\(t_m\)</span> and we need to
iterate over all space-time indices to calculate the correct
value.</p>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">              </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\((u^+, v^+)\)</span></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">                      </span><span class="n">cell_matrix</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">,</span>
<span class="w">                                  </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">)</span><span class="w"> </span><span class="o">+=</span>
<span class="w">                        </span><span class="n">fe_jump_values_spacetime</span><span class="p">.</span><span class="n">shape_value_plus</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                        </span><span class="n">fe_jump_values_spacetime</span><span class="p">.</span><span class="n">shape_value_plus</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                        </span><span class="n">fe_jump_values_spacetime</span><span class="p">.</span><span class="n">JxW</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\(-(u^-, v^+)\)</span>
If we have more than a single element per slab,
we have to calculate the inner jumps between elements.
Therefore, the column index is offset by one temporal
element</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">                      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                          </span><span class="n">cell_matrix</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">)</span><span class="w"> </span><span class="o">-=</span>
<span class="w">                            </span><span class="n">fe_jump_values_spacetime</span><span class="p">.</span><span class="n">shape_value_plus</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                            </span><span class="n">fe_jump_values_spacetime</span><span class="p">.</span><span class="n">shape_value_minus</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                            </span><span class="n">fe_jump_values_spacetime</span><span class="p">.</span><span class="n">JxW</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                    </span><span class="p">}</span><span class="w"> </span><span class="c1">// dofs j</span>
</pre></div>
</div>
<p>The first temporal element has to account for the jump
to the previous slab in the right hand side.
For <code class="docutils literal notranslate"><span class="pre">slab==0</span></code> this is the initial value of the problem.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">                  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                      </span><span class="n">cell_rhs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">+=</span>
<span class="w">                        </span><span class="n">fe_jump_values_spacetime</span><span class="p">.</span><span class="n">shape_value_plus</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                        </span><span class="n">initial_values</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="w"> </span><span class="c1">// value of previous solution at t0</span>
<span class="w">                        </span><span class="o">*</span><span class="w"> </span><span class="n">fe_jump_values_spacetime</span><span class="p">.</span><span class="n">JxW</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="c1">// dofs i</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="c1">// cell time</span>
</pre></div>
</div>
<p>Write the contribution of the space-time elements related to the
current spatial element into the system matrix and rhs</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">      </span><span class="n">slab_constraints</span><span class="o">-&gt;</span><span class="n">distribute_local_to_global</span><span class="p">(</span><span class="n">cell_matrix</span><span class="p">,</span>
<span class="w">                                                   </span><span class="n">cell_rhs</span><span class="p">,</span>
<span class="w">                                                   </span><span class="n">local_spacetime_dof_index</span><span class="p">,</span>
<span class="w">                                                   </span><span class="n">slab_system_matrix</span><span class="p">,</span>
<span class="w">                                                   </span><span class="n">slab_system_rhs</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// cell space</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="step1-solve-system-on-slab">
<h4><a class="toc-backref" href="#id19" role="doc-backlink">Step1::solve_system_on_slab</a><a class="headerlink" href="#step1-solve-system-on-slab" title="Link to this heading"></a></h4>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">Step1::solve_system_on_slab</span><span class="p">()</span>
<span class="p">{</span>
</pre></div>
</div>
<p>Simply use a direct solver here. CG would not work as the matrix is not
symmetric!</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">dealii</span><span class="o">::</span><span class="n">SparseDirectUMFPACK</span><span class="w"> </span><span class="n">solver</span><span class="p">;</span>
<span class="w">  </span><span class="n">solver</span><span class="p">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">slab_system_matrix</span><span class="p">);</span>
<span class="w">  </span><span class="n">solver</span><span class="p">.</span><span class="n">vmult</span><span class="p">(</span><span class="o">*</span><span class="n">slab_its</span><span class="p">.</span><span class="n">solution</span><span class="p">,</span><span class="w"> </span><span class="n">slab_system_rhs</span><span class="p">);</span>
</pre></div>
</div>
<p>After solving, set the correct Dirichlet values in the solution</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">slab_constraints</span><span class="o">-&gt;</span><span class="n">distribute</span><span class="p">(</span><span class="o">*</span><span class="n">slab_its</span><span class="p">.</span><span class="n">solution</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="step1-output-results-on-slab">
<h4><a class="toc-backref" href="#id20" role="doc-backlink">Step1::output_results_on_slab</a><a class="headerlink" href="#step1-output-results-on-slab" title="Link to this heading"></a></h4>
<p>For now the output is done somewhat by hand.
A spacetime or slab DataOut object is planned/WIP.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">Step1::output_results_on_slab</span><span class="p">()</span>
<span class="p">{</span>
</pre></div>
</div>
<p>Simply output the subvectors at all temporal degrees of freedom.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">n_dofs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">n_dofs_time</span><span class="p">();</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n_dofs</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
</pre></div>
</div>
<p>Construct a spatial <code class="docutils literal notranslate"><span class="pre">DataOut</span></code> object and attach the spatial component
of the <code class="docutils literal notranslate"><span class="pre">DoFHandler</span></code></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">      </span><span class="n">dealii</span><span class="o">::</span><span class="n">DataOut</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">data_out</span><span class="p">;</span>
<span class="w">      </span><span class="n">data_out</span><span class="p">.</span><span class="n">attach_dof_handler</span><span class="p">(</span><span class="o">*</span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">spatial</span><span class="p">());</span>
</pre></div>
</div>
<p>Extract the spatial solution at the current temporal dof</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">      </span><span class="n">dealii</span><span class="o">::</span><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">local_solution</span><span class="p">;</span>
<span class="w">      </span><span class="n">local_solution</span><span class="p">.</span><span class="n">reinit</span><span class="p">(</span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">n_dofs_space</span><span class="p">());</span>
<span class="w">      </span><span class="n">idealii</span><span class="o">::</span><span class="n">slab</span><span class="o">::</span><span class="n">VectorTools</span><span class="o">::</span><span class="n">extract_subvector_at_time_dof</span><span class="p">(</span>
<span class="w">        </span><span class="o">*</span><span class="n">slab_its</span><span class="p">.</span><span class="n">solution</span><span class="p">,</span><span class="w"> </span><span class="n">local_solution</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
</pre></div>
</div>
<p>Add this vector to the DataOut object</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">      </span><span class="n">data_out</span><span class="p">.</span><span class="n">add_data_vector</span><span class="p">(</span><span class="n">local_solution</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Solution&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="n">data_out</span><span class="p">.</span><span class="n">build_patches</span><span class="p">();</span>
</pre></div>
</div>
<p>Construct a filename. For a fixed triangulation with uniform refinement
this is relatively easy, as all slabs have the same number of temporal
degrees of freedom.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span><span class="w"> </span><span class="n">filename</span><span class="p">;</span>
<span class="w">      </span><span class="n">filename</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;solution_split_dG(&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fe</span><span class="p">.</span><span class="n">temporal</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">degree</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;)_t_&quot;</span>
<span class="w">               </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">slab</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_dofs</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;.vtk&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Open and output filestream and write the information for the current
temporal DoF.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="n">filename</span><span class="p">.</span><span class="n">str</span><span class="p">());</span>
<span class="w">      </span><span class="n">data_out</span><span class="p">.</span><span class="n">write_vtk</span><span class="p">(</span><span class="n">output</span><span class="p">);</span>
<span class="w">      </span><span class="n">output</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="the-main-function">
<h3><a class="toc-backref" href="#id21" role="doc-backlink">The main function</a><a class="headerlink" href="#the-main-function" title="Link to this heading"></a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span>
<span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// spatial finite element order</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// temporal finite element order</span>

<span class="w">  </span><span class="n">Step1</span><span class="w"> </span><span class="n">problem</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span>
<span class="w">  </span><span class="n">problem</span><span class="p">.</span><span class="n">run</span><span class="p">();</span><span class="w"> </span><span class="c1">// run the problem with cG(s)dG(r) finite elements</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="results">
<h2><a class="toc-backref" href="#id22" role="doc-backlink">Results</a><a class="headerlink" href="#results" title="Link to this heading"></a></h2>
<p>The first lines of output of the program look as follows:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">*******Starting time-stepping*********</span>
<span class="go">Starting time-step (0,0.01]</span>
<span class="go">Number of degrees of freedom:</span>
<span class="go">        4225 (space) * 1 (time) = 4225</span>
<span class="go">Starting time-step (0.01,0.02]</span>
<span class="go">Number of degrees of freedom:</span>
<span class="go">        4225 (space) * 1 (time) = 4225</span>
</pre></div>
</div>
<p>Note that this output of course depends on the number
temporal elements <span class="math notranslate nohighlight">\(M\)</span> of spatial
refinements as set in <code class="docutils literal notranslate"><span class="pre">make_grid()</span></code> as well as the chosen
finite elements.
For a dG(1) discretization in time the output would instead be:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">*******Starting time-stepping*********</span>
<span class="go">Starting time-step (0,0.01]</span>
<span class="go">Number of degrees of freedom:</span>
<span class="go">        4225 (space) * 2 (time) = 8450</span>
<span class="go">Starting time-step (0.01,0.02]</span>
<span class="go">Number of degrees of freedom:</span>
<span class="go">        4225 (space) * 2 (time) = 8450</span>
</pre></div>
</div>
<p>Note that we would also get the above output with dG(0) elements
and a single temporal refinement, which results in two temporal
elements per slab.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">.vtk</span></code> files generated during output can be opened by many
visualization programs, including <a class="reference external" href="https://www.paraview.org/">Paraview</a>
and <a class="reference external" href="https://visit-dav.github.io/visit-website/">VisIt</a>.
Since the solution is time dependent we have used Paraview to generate
the following video:</p>
<video autoplay="True" controls="True" height="500" loop="True" preload="auto"><source src="../_images/step-1.ogv" type="video/ogg"></video><p>It shows the solution, i.e. the function <span class="math notranslate nohighlight">\((x^2-x)(y^2-y)/4\)</span>
scaled by <span class="math notranslate nohighlight">\(t\)</span>.</p>
<section id="possibilities-for-extensions">
<h3><a class="toc-backref" href="#id23" role="doc-backlink">Possibilities for extensions</a><a class="headerlink" href="#possibilities-for-extensions" title="Link to this heading"></a></h3>
<p>If you want to play around with this program here are a few suggestions:</p>
<ul class="simple">
<li><p>Change the geometry and mesh: We generated a square domain but deal.II’s
<cite>GridGenerator &lt;https://dealii.org/current/doxygen/deal.II/namespaceGridGenerator.html&gt;_</cite>
has quite a few other options.</p></li>
<li><p>Change the finite element orders: A big advantage of space-time finite
elements is the possibility to change the convergence order of the
temporal discretization by increasing the degree of the temporal elements.
Note, that the approximate solution might seem wrong initially as it
‘wiggles’  when going through the output files.
This is however correct.
What we see are the two different values at each inner temporal edge
due to the discontinuous Galerkin discretization.</p></li>
<li><p>Observe convergence: We will discuss computing the <span class="math notranslate nohighlight">\(L^2(Q)\)</span>-error
in <a class="reference internal" href="step-3.html#step-3"><span class="std std-ref">Example 3: Solving the heat equation in parallel</span></a> where the given exact solution is much more challenging
in time compared to the linear behaviour of <span class="math notranslate nohighlight">\(u\)</span>.
This will allow us to study the performance of different
temporal and spatial element orders.
Here, we could instead use <code class="docutils literal notranslate"><span class="pre">dealii::VectorTools::compute_mean_value()</span></code>
for the spatial solution on each temporal element and average them
over the temporal interval.
Integrating the exact solution over <span class="math notranslate nohighlight">\((0,T)\times\Omega\)</span>
and dividing by <span class="math notranslate nohighlight">\(|\Omega|T\)</span> we get the expected value <span class="math notranslate nohighlight">\(-T/288\)</span>
to which the approximated mean value will converge.</p></li>
</ul>
</section>
</section>
<section id="the-plain-program">
<h2><a class="toc-backref" href="#id24" role="doc-backlink">The plain program</a><a class="headerlink" href="#the-plain-program" title="Link to this heading"></a></h2>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ideal.II/base/time_iterator.hh&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ideal.II/base/quadrature_lib.hh&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ideal.II/dofs/slab_dof_tools.hh&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ideal.II/dofs/spacetime_dof_handler.hh&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ideal.II/fe/fe_dg.hh&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ideal.II/fe/spacetime_fe_values.hh&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ideal.II/grid/fixed_tria.hh&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ideal.II/lac/spacetime_vector.hh&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ideal.II/numerics/vector_tools.hh&gt;</span>


<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deal.II/fe/fe_q.h&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deal.II/grid/grid_generator.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deal.II/grid/tria.h&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deal.II/lac/full_matrix.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deal.II/lac/sparse_direct.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deal.II/lac/sparse_matrix.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deal.II/lac/vector.h&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deal.II/base/function.h&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;deal.II/numerics/data_out.h&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fstream&gt;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ExactSolution</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">Function</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">ExactSolution</span><span class="p">()</span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">Function</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="p">()</span>
<span class="w">  </span><span class="p">{}</span>
<span class="w">  </span><span class="kt">double</span>
<span class="w">  </span><span class="n">value</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">Point</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">double</span>
<span class="nf">ExactSolution::value</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">Point</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w">             </span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span>
<span class="w">                     </span><span class="p">[[</span><span class="n">maybe_unused</span><span class="p">]]</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">component</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_time</span><span class="p">();</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.25</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span><span class="w"> </span><span class="nc">RightHandSide</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">Function</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">double</span>
<span class="w">  </span><span class="n">value</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">Point</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">double</span>
<span class="nf">RightHandSide::value</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">Point</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w">             </span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span>
<span class="w">                     </span><span class="p">[[</span><span class="n">maybe_unused</span><span class="p">]]</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">component</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">t</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="n">get_time</span><span class="p">();</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">return_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="n">return_value</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="w">  </span><span class="n">return_value</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="w">  </span><span class="n">return_value</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.25</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">return_value</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Step1</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">Step1</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">spatial_degree</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">temporal_degree</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span>
<span class="w">  </span><span class="nf">run</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span>
<span class="w">  </span><span class="n">make_grid</span><span class="p">();</span>
<span class="w">  </span><span class="kt">void</span>
<span class="w">  </span><span class="nf">time_marching</span><span class="p">();</span>
<span class="w">  </span><span class="kt">void</span>
<span class="w">  </span><span class="nf">setup_system_on_slab</span><span class="p">();</span>
<span class="w">  </span><span class="kt">void</span>
<span class="w">  </span><span class="nf">assemble_system_on_slab</span><span class="p">();</span>
<span class="w">  </span><span class="kt">void</span>
<span class="w">  </span><span class="nf">solve_system_on_slab</span><span class="p">();</span>
<span class="w">  </span><span class="kt">void</span>
<span class="w">  </span><span class="nf">output_results_on_slab</span><span class="p">();</span>

<span class="w">  </span><span class="n">idealii</span><span class="o">::</span><span class="n">spacetime</span><span class="o">::</span><span class="n">fixed</span><span class="o">::</span><span class="n">Triangulation</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">triangulation</span><span class="p">;</span>
<span class="w">  </span><span class="n">idealii</span><span class="o">::</span><span class="n">spacetime</span><span class="o">::</span><span class="n">DoFHandler</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w">           </span><span class="n">dof_handler</span><span class="p">;</span>
<span class="w">  </span><span class="n">idealii</span><span class="o">::</span><span class="n">spacetime</span><span class="o">::</span><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w">          </span><span class="n">solution</span><span class="p">;</span>

<span class="w">  </span><span class="n">idealii</span><span class="o">::</span><span class="n">spacetime</span><span class="o">::</span><span class="n">DG_FiniteElement</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fe</span><span class="p">;</span>



<span class="w">  </span><span class="n">dealii</span><span class="o">::</span><span class="n">SparsityPattern</span><span class="w">                            </span><span class="n">slab_sparsity_pattern</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">dealii</span><span class="o">::</span><span class="n">AffineConstraints</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">slab_constraints</span><span class="p">;</span>
<span class="w">  </span><span class="n">dealii</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w">                       </span><span class="n">slab_system_matrix</span><span class="p">;</span>
<span class="w">  </span><span class="n">dealii</span><span class="o">::</span><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w">                             </span><span class="n">slab_system_rhs</span><span class="p">;</span>
<span class="w">  </span><span class="n">dealii</span><span class="o">::</span><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w">                             </span><span class="n">slab_initial_value</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">slab</span><span class="p">;</span><span class="w"> </span><span class="c1">// index of the current slab</span>

<span class="w">  </span><span class="k">struct</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">idealii</span><span class="o">::</span><span class="n">slab</span><span class="o">::</span><span class="n">TriaIterator</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w">        </span><span class="n">tria</span><span class="p">;</span>
<span class="w">    </span><span class="n">idealii</span><span class="o">::</span><span class="n">slab</span><span class="o">::</span><span class="n">DoFHandlerIterator</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w">  </span><span class="n">dof</span><span class="p">;</span>
<span class="w">    </span><span class="n">idealii</span><span class="o">::</span><span class="n">slab</span><span class="o">::</span><span class="n">VectorIterator</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">solution</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">slab_its</span><span class="p">;</span>
<span class="p">};</span>



<span class="n">Step1</span><span class="o">::</span><span class="n">Step1</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">spatial_degree</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">temporal_degree</span><span class="p">)</span>
<span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="n">triangulation</span><span class="p">()</span><span class="w"> </span><span class="c1">// space-time triangulation</span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">dof_handler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">triangulation</span><span class="p">)</span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">fe</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">dealii</span><span class="o">::</span><span class="n">FE_Q</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">spatial_degree</span><span class="p">),</span><span class="w"> </span><span class="n">temporal_degree</span><span class="p">)</span>
<span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">slab</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">{}</span>



<span class="kt">void</span>
<span class="n">Step1</span><span class="o">::</span><span class="n">run</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">make_grid</span><span class="p">();</span>
<span class="w">  </span><span class="n">time_marching</span><span class="p">();</span>
<span class="p">}</span>


<span class="kt">void</span>
<span class="n">Step1</span><span class="o">::</span><span class="n">make_grid</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">space_tria</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">dealii</span><span class="o">::</span><span class="n">Triangulation</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="n">dealii</span><span class="o">::</span><span class="n">GridGenerator</span><span class="o">::</span><span class="n">hyper_cube</span><span class="p">(</span><span class="o">*</span><span class="n">space_tria</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">  </span><span class="n">triangulation</span><span class="p">.</span><span class="n">generate</span><span class="p">(</span><span class="n">space_tria</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">);</span>
<span class="w">  </span><span class="n">triangulation</span><span class="p">.</span><span class="n">refine_global</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">dof_handler</span><span class="p">.</span><span class="n">generate</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="n">Step1</span><span class="o">::</span><span class="n">time_marching</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">idealii</span><span class="o">::</span><span class="n">TimeIteratorCollection</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">idealii</span><span class="o">::</span><span class="n">TimeIteratorCollection</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">  </span><span class="n">solution</span><span class="p">.</span><span class="n">reinit</span><span class="p">(</span><span class="n">triangulation</span><span class="p">.</span><span class="n">M</span><span class="p">());</span>

<span class="w">  </span><span class="n">slab_its</span><span class="p">.</span><span class="n">tria</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">triangulation</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="w">  </span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">dof_handler</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="w">  </span><span class="n">slab_its</span><span class="p">.</span><span class="n">solution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solution</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

<span class="w">  </span><span class="n">tic</span><span class="p">.</span><span class="n">add_iterator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slab_its</span><span class="p">.</span><span class="n">tria</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">triangulation</span><span class="p">);</span>
<span class="w">  </span><span class="n">tic</span><span class="p">.</span><span class="n">add_iterator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dof_handler</span><span class="p">);</span>
<span class="w">  </span><span class="n">tic</span><span class="p">.</span><span class="n">add_iterator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slab_its</span><span class="p">.</span><span class="n">solution</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">solution</span><span class="p">);</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;*******Starting time-stepping*********&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">  </span><span class="n">slab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="o">!</span><span class="n">tic</span><span class="p">.</span><span class="n">at_end</span><span class="p">();</span><span class="w"> </span><span class="n">tic</span><span class="p">.</span><span class="n">increment</span><span class="p">())</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Starting time-step (&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">slab_its</span><span class="p">.</span><span class="n">tria</span><span class="o">-&gt;</span><span class="n">startpoint</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;,&quot;</span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">slab_its</span><span class="p">.</span><span class="n">tria</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">      </span><span class="n">setup_system_on_slab</span><span class="p">();</span>
<span class="w">      </span><span class="n">assemble_system_on_slab</span><span class="p">();</span>
<span class="w">      </span><span class="n">solve_system_on_slab</span><span class="p">();</span>
<span class="w">      </span><span class="n">output_results_on_slab</span><span class="p">();</span>

<span class="w">      </span><span class="n">idealii</span><span class="o">::</span><span class="n">slab</span><span class="o">::</span><span class="n">VectorTools</span><span class="o">::</span><span class="n">extract_subvector_at_time_dof</span><span class="p">(</span>
<span class="w">        </span><span class="o">*</span><span class="n">slab_its</span><span class="p">.</span><span class="n">solution</span><span class="p">,</span>
<span class="w">        </span><span class="n">slab_initial_value</span><span class="p">,</span>
<span class="w">        </span><span class="n">slab_its</span><span class="p">.</span><span class="n">tria</span><span class="o">-&gt;</span><span class="n">temporal</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">n_global_active_cells</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">      </span><span class="n">slab</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="n">Step1</span><span class="o">::</span><span class="n">setup_system_on_slab</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">distribute_dofs</span><span class="p">(</span><span class="n">fe</span><span class="p">);</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Number of degrees of freedom: </span><span class="se">\n\t</span><span class="s">&quot;</span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">n_dofs_space</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; (space) * &quot;</span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">n_dofs_time</span><span class="p">()</span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; (time) = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">n_dofs_spacetime</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">slab</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">slab_initial_value</span><span class="p">.</span><span class="n">reinit</span><span class="p">(</span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">n_dofs_space</span><span class="p">());</span>
<span class="w">      </span><span class="n">slab_initial_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">  </span><span class="n">slab_constraints</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">dealii</span><span class="o">::</span><span class="n">AffineConstraints</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">zero</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">Functions</span><span class="o">::</span><span class="n">ZeroFunction</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="n">idealii</span><span class="o">::</span><span class="n">slab</span><span class="o">::</span><span class="n">VectorTools</span><span class="o">::</span><span class="n">interpolate_boundary_values</span><span class="p">(</span><span class="o">*</span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="p">,</span>
<span class="w">                                                          </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                                                          </span><span class="n">zero</span><span class="p">,</span>
<span class="w">                                                          </span><span class="n">slab_constraints</span><span class="p">);</span>
<span class="w">  </span><span class="n">slab_constraints</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">();</span>

<span class="w">  </span><span class="n">dealii</span><span class="o">::</span><span class="n">DynamicSparsityPattern</span><span class="w"> </span><span class="nf">dsp</span><span class="p">(</span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">n_dofs_spacetime</span><span class="p">());</span>
<span class="w">  </span><span class="n">idealii</span><span class="o">::</span><span class="n">slab</span><span class="o">::</span><span class="n">DoFTools</span><span class="o">::</span><span class="n">make_upwind_sparsity_pattern</span><span class="p">(</span><span class="o">*</span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="p">,</span><span class="w"> </span><span class="n">dsp</span><span class="p">);</span>
<span class="w">  </span><span class="n">slab_sparsity_pattern</span><span class="p">.</span><span class="n">copy_from</span><span class="p">(</span><span class="n">dsp</span><span class="p">);</span>

<span class="w">  </span><span class="n">slab_system_matrix</span><span class="p">.</span><span class="n">reinit</span><span class="p">(</span><span class="n">slab_sparsity_pattern</span><span class="p">);</span>
<span class="w">  </span><span class="n">slab_its</span><span class="p">.</span><span class="n">solution</span><span class="o">-&gt;</span><span class="n">reinit</span><span class="p">(</span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">n_dofs_spacetime</span><span class="p">());</span>
<span class="w">  </span><span class="n">slab_system_rhs</span><span class="p">.</span><span class="n">reinit</span><span class="p">(</span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">n_dofs_spacetime</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="n">Step1</span><span class="o">::</span><span class="n">assemble_system_on_slab</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">idealii</span><span class="o">::</span><span class="n">spacetime</span><span class="o">::</span><span class="n">QGauss</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">quad</span><span class="p">(</span><span class="n">fe</span><span class="p">.</span><span class="n">spatial</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">degree</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">fe</span><span class="p">.</span><span class="n">temporal</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">degree</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>

<span class="w">  </span><span class="n">idealii</span><span class="o">::</span><span class="n">spacetime</span><span class="o">::</span><span class="n">FEValues</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fe_values_spacetime</span><span class="p">(</span>
<span class="w">    </span><span class="n">fe</span><span class="p">,</span>
<span class="w">    </span><span class="n">quad</span><span class="p">,</span>
<span class="w">    </span><span class="n">dealii</span><span class="o">::</span><span class="n">update_values</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">update_gradients</span><span class="w"> </span><span class="o">|</span>
<span class="w">      </span><span class="n">dealii</span><span class="o">::</span><span class="n">update_quadrature_points</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">update_JxW_values</span><span class="p">);</span>

<span class="w">  </span><span class="n">idealii</span><span class="o">::</span><span class="n">spacetime</span><span class="o">::</span><span class="n">FEJumpValues</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fe_jump_values_spacetime</span><span class="p">(</span>
<span class="w">    </span><span class="n">fe</span><span class="p">,</span>
<span class="w">    </span><span class="n">quad</span><span class="p">,</span>
<span class="w">    </span><span class="n">dealii</span><span class="o">::</span><span class="n">update_values</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">update_gradients</span><span class="w"> </span><span class="o">|</span>
<span class="w">      </span><span class="n">dealii</span><span class="o">::</span><span class="n">update_quadrature_points</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">dealii</span><span class="o">::</span><span class="n">update_JxW_values</span><span class="p">);</span>

<span class="w">  </span><span class="n">RightHandSide</span><span class="w">      </span><span class="n">right_hand_side</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fe</span><span class="p">.</span><span class="n">dofs_per_cell</span><span class="p">;</span>

<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slab_its</span><span class="p">.</span><span class="n">tria</span><span class="o">-&gt;</span><span class="n">temporal</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">n_global_active_cells</span><span class="p">();</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>

<span class="w">  </span><span class="n">dealii</span><span class="o">::</span><span class="n">FullMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cell_matrix</span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">);</span>

<span class="w">  </span><span class="n">dealii</span><span class="o">::</span><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cell_rhs</span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">);</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">dealii</span><span class="o">::</span><span class="n">types</span><span class="o">::</span><span class="n">global_dof_index</span><span class="o">&gt;</span><span class="w"> </span><span class="n">local_spacetime_dof_index</span><span class="p">(</span>
<span class="w">    </span><span class="n">N</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">);</span>

<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n_quad_spacetime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">n_quadrature_points</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n_quad_space</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">quad</span><span class="p">.</span><span class="n">spatial</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cell_space</span><span class="w"> </span><span class="o">:</span>
<span class="w">       </span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">spatial</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">active_cell_iterators</span><span class="p">())</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">cell_matrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">      </span><span class="n">cell_rhs</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">      </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">reinit_space</span><span class="p">(</span><span class="n">cell_space</span><span class="p">);</span>
<span class="w">      </span><span class="n">fe_jump_values_spacetime</span><span class="p">.</span><span class="n">reinit_space</span><span class="p">(</span><span class="n">cell_space</span><span class="p">);</span>

<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">initial_values</span><span class="p">(</span>
<span class="w">        </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">spatial</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">n_quadrature_points</span><span class="p">);</span>
<span class="w">      </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">spatial</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">get_function_values</span><span class="p">(</span><span class="n">slab_initial_value</span><span class="p">,</span>
<span class="w">                                                         </span><span class="n">initial_values</span><span class="p">);</span>

<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cell_time</span><span class="w"> </span><span class="o">:</span>
<span class="w">           </span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">temporal</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">active_cell_iterators</span><span class="p">())</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">          </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell_time</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">();</span>

<span class="w">          </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">reinit_time</span><span class="p">(</span><span class="n">cell_time</span><span class="p">);</span>
<span class="w">          </span><span class="n">fe_jump_values_spacetime</span><span class="p">.</span><span class="n">reinit_time</span><span class="p">(</span><span class="n">cell_time</span><span class="p">);</span>

<span class="w">          </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">get_local_dof_indices</span><span class="p">(</span><span class="n">local_spacetime_dof_index</span><span class="p">);</span>

<span class="w">          </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n_quad_spacetime</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">q</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">              </span><span class="n">right_hand_side</span><span class="p">.</span><span class="n">set_time</span><span class="p">(</span>
<span class="w">                </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">time_quadrature_point</span><span class="p">(</span><span class="n">q</span><span class="p">));</span>
<span class="w">              </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x_q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">space_quadrature_point</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

<span class="w">              </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>


<span class="w">                      </span><span class="n">cell_matrix</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">,</span>
<span class="w">                                  </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">)</span><span class="w"> </span><span class="o">+=</span>
<span class="w">                        </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">shape_value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                        </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">shape_dt</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                        </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">JxW</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

<span class="w">                      </span><span class="n">cell_matrix</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">,</span>
<span class="w">                                  </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">)</span><span class="w"> </span><span class="o">+=</span>
<span class="w">                        </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">shape_space_grad</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                        </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">shape_space_grad</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                        </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">JxW</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

<span class="w">                    </span><span class="p">}</span><span class="w"> </span><span class="c1">// dofs j</span>

<span class="w">                  </span><span class="n">cell_rhs</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">)</span><span class="w"> </span><span class="o">+=</span>
<span class="w">                    </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">shape_value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                    </span><span class="n">right_hand_side</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">x_q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fe_values_spacetime</span><span class="p">.</span><span class="n">JxW</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="c1">// dofs i</span>

<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="c1">// quad</span>

<span class="w">          </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n_quad_space</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">q</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">              </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                      </span><span class="n">cell_matrix</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">,</span>
<span class="w">                                  </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">)</span><span class="w"> </span><span class="o">+=</span>
<span class="w">                        </span><span class="n">fe_jump_values_spacetime</span><span class="p">.</span><span class="n">shape_value_plus</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                        </span><span class="n">fe_jump_values_spacetime</span><span class="p">.</span><span class="n">shape_value_plus</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                        </span><span class="n">fe_jump_values_spacetime</span><span class="p">.</span><span class="n">JxW</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

<span class="w">                      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                        </span><span class="p">{</span>
<span class="w">                          </span><span class="n">cell_matrix</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dofs_per_spacetime_cell</span><span class="p">)</span><span class="w"> </span><span class="o">-=</span>
<span class="w">                            </span><span class="n">fe_jump_values_spacetime</span><span class="p">.</span><span class="n">shape_value_plus</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                            </span><span class="n">fe_jump_values_spacetime</span><span class="p">.</span><span class="n">shape_value_minus</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                            </span><span class="n">fe_jump_values_spacetime</span><span class="p">.</span><span class="n">JxW</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="w">                        </span><span class="p">}</span>
<span class="w">                    </span><span class="p">}</span><span class="w"> </span><span class="c1">// dofs j</span>

<span class="w">                  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                      </span><span class="n">cell_rhs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">+=</span>
<span class="w">                        </span><span class="n">fe_jump_values_spacetime</span><span class="p">.</span><span class="n">shape_value_plus</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">*</span>
<span class="w">                        </span><span class="n">initial_values</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="w"> </span><span class="c1">// value of previous solution at t0</span>
<span class="w">                        </span><span class="o">*</span><span class="w"> </span><span class="n">fe_jump_values_spacetime</span><span class="p">.</span><span class="n">JxW</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="c1">// dofs i</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="c1">// cell time</span>

<span class="w">      </span><span class="n">slab_constraints</span><span class="o">-&gt;</span><span class="n">distribute_local_to_global</span><span class="p">(</span><span class="n">cell_matrix</span><span class="p">,</span>
<span class="w">                                                   </span><span class="n">cell_rhs</span><span class="p">,</span>
<span class="w">                                                   </span><span class="n">local_spacetime_dof_index</span><span class="p">,</span>
<span class="w">                                                   </span><span class="n">slab_system_matrix</span><span class="p">,</span>
<span class="w">                                                   </span><span class="n">slab_system_rhs</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// cell space</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="n">Step1</span><span class="o">::</span><span class="n">solve_system_on_slab</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">dealii</span><span class="o">::</span><span class="n">SparseDirectUMFPACK</span><span class="w"> </span><span class="n">solver</span><span class="p">;</span>
<span class="w">  </span><span class="n">solver</span><span class="p">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">slab_system_matrix</span><span class="p">);</span>
<span class="w">  </span><span class="n">solver</span><span class="p">.</span><span class="n">vmult</span><span class="p">(</span><span class="o">*</span><span class="n">slab_its</span><span class="p">.</span><span class="n">solution</span><span class="p">,</span><span class="w"> </span><span class="n">slab_system_rhs</span><span class="p">);</span>
<span class="w">  </span><span class="n">slab_constraints</span><span class="o">-&gt;</span><span class="n">distribute</span><span class="p">(</span><span class="o">*</span><span class="n">slab_its</span><span class="p">.</span><span class="n">solution</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span>
<span class="n">Step1</span><span class="o">::</span><span class="n">output_results_on_slab</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">n_dofs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">n_dofs_time</span><span class="p">();</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n_dofs</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">dealii</span><span class="o">::</span><span class="n">DataOut</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">data_out</span><span class="p">;</span>
<span class="w">      </span><span class="n">data_out</span><span class="p">.</span><span class="n">attach_dof_handler</span><span class="p">(</span><span class="o">*</span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">spatial</span><span class="p">());</span>

<span class="w">      </span><span class="n">dealii</span><span class="o">::</span><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">local_solution</span><span class="p">;</span>
<span class="w">      </span><span class="n">local_solution</span><span class="p">.</span><span class="n">reinit</span><span class="p">(</span><span class="n">slab_its</span><span class="p">.</span><span class="n">dof</span><span class="o">-&gt;</span><span class="n">n_dofs_space</span><span class="p">());</span>
<span class="w">      </span><span class="n">idealii</span><span class="o">::</span><span class="n">slab</span><span class="o">::</span><span class="n">VectorTools</span><span class="o">::</span><span class="n">extract_subvector_at_time_dof</span><span class="p">(</span>
<span class="w">        </span><span class="o">*</span><span class="n">slab_its</span><span class="p">.</span><span class="n">solution</span><span class="p">,</span><span class="w"> </span><span class="n">local_solution</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>

<span class="w">      </span><span class="n">data_out</span><span class="p">.</span><span class="n">add_data_vector</span><span class="p">(</span><span class="n">local_solution</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Solution&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="n">data_out</span><span class="p">.</span><span class="n">build_patches</span><span class="p">();</span>

<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span><span class="w"> </span><span class="n">filename</span><span class="p">;</span>
<span class="w">      </span><span class="n">filename</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;solution_split_dG(&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fe</span><span class="p">.</span><span class="n">temporal</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">degree</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;)_t_&quot;</span>
<span class="w">               </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">slab</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_dofs</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;.vtk&quot;</span><span class="p">;</span>

<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="w"> </span><span class="nf">output</span><span class="p">(</span><span class="n">filename</span><span class="p">.</span><span class="n">str</span><span class="p">());</span>
<span class="w">      </span><span class="n">data_out</span><span class="p">.</span><span class="n">write_vtk</span><span class="p">(</span><span class="n">output</span><span class="p">);</span>
<span class="w">      </span><span class="n">output</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// spatial finite element order</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// temporal finite element order</span>

<span class="w">  </span><span class="n">Step1</span><span class="w"> </span><span class="nf">problem</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span>
<span class="w">  </span><span class="n">problem</span><span class="p">.</span><span class="n">run</span><span class="p">();</span><span class="w"> </span><span class="c1">// run the problem with cG(s)dG(r) finite elements</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="overview.html" class="btn btn-neutral float-left" title="Example overview" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="step-2.html" class="btn btn-neutral float-right" title="Example 2: Solving the linear Stokes equation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, the ideal.II authors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>